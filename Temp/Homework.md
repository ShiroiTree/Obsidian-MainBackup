### 2.2
1. 在顺序表中插入或删除一个元素，平均需要移动<u> n/2 个 </u>元素，具体移动的元素个数与<u> 该元素的位置 </u>有关。
2. 顺序表中逻辑上相邻的元素的物理位置<u> 必定 </u>紧邻，单链表中逻辑上相邻的元素的物理位置<u> 不一定 </u>紧邻。
3. 在单链表中，除了首元结点外，任一结点的储存位置由<u> 其直接前驱结点的链域的值 </u>指示。
4. 在单链表中设置头结点的作用是，<u> 插入和删除首元素时不必进行特殊处理</u>。
### 2.8 已知P结点是某双链表的中间结点，试从下列提供的答案中选择合适的语句序列、
1. 在P结点后插入S结点的语句序列是<u> 12、7、3、6 </u>
2. 在P结点前插入S结点的语句序列是<u> 13、8、5、4 </u>
3. 删除P结点的直接后继结点的语句序列是<u> 15、1、11、18 </u>
4. 删除P结点的直接前驱结点语句序列是<u> 16、2、10、18 </u>
5. 删除P结点的语句序列是<u> 9、14、17 </u>
### 2.11 设顺序表va中的元素递增有序。试写一算法，将x插入到顺序表的适当位置上，以保持该表的有序性。
```
Status InsertOrderList(SqList &a, ElemType x)
{
    if (a.lenth == a.listsize)
        return OVERFLOW;
    else
    {
        i = a.lenth - 1;
        while (i>=0&&x<a.elem[i])
        {
            i--;
        }
        for (j=a.lenth-1;j>=i+1;i--)
        {
            a.elem[j+1]=a.elem[j];
        }
        a.elem[i+1]=x;
        a.length++;
        return OK;
    }
}
```
### 2.21 试写一算法，实现顺序表的就地逆置，即利用原表的存储空间将线性表（a1,a2,…,an）逆置为(an,an-1,...,a1)
分别读出线性表的首元素和尾元素，依次相互交换即可将顺序表就地逆置。
### 2.22 试写一算法，对单链表实现就地逆置。
从头节点开始修改单链表，将原先的后继结点映射为前驱结点即可。
### 2.24 假设有两个按元素值递增有序排列的线性表 A 和B，均以单链表作存储结构，请编写算法将 A表和B 表归并成一个按元素值递减有序（即非递增有序，允许表中含有值相同的元素）排列的线性表C，并要求利用原表（即A表和B表）的结点空间构造C表。
分别读取线性表A、B的头节点，依次比较大小，将较小元素排列至A表表头，再比较下一对元素大小。依次构造顺序表C。
### 2.29 已知A，B和C为三个递增有序的线性表，现要求对A表作如下操作：删去那些既在B表中出现，又在C表中出现的元素。试对顺序表编写实现上述操作的算法，并分析你的算法的时间复杂度。
依次在B、C表中顺序查找A中出现的元素，一旦查找到便删除A中对应元素，直到扫描到A表末尾再处理被删除元素留下的空白。
### 2.38 设有一个双向循环链表，每个结点中除有prior, data 和 next 三个域外，还增设了一个访问频度域freq。在链表被起用之前，频度域freq的值均初始化为零，而每当对链表进行一次访问后，被访问的结点freq+1，并重新排列链表，使频度较高的元素位于表头。
在每次访问到对应元素后，freq+1，链表重新排列。以被访问的目标节点为首结点向前遍历，每次遍历验证本结点与前驱结点freq大小关系，直到将本结点移到前驱结点freq大于本结点的位置。
